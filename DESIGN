
gestione memoria: segmenti per ogni sezione (chanserv, nickserv) allocati e gestiti da una lib ( da scrivere ).
	funzionamento:

	innanzitutto queste funzioni sono da intendersi come sistemi di gestione della memoria allocata a dei record
	presenti in una struttura dati quale lista, hashtable, albero binario etc.
	per la nostra implementazione utilizzaremo una hashtable.
	ogni elemento della hashtable e` un puntatore ad una struttura dati di dimensione fissa.
	ad esempio: 
	
	typedef struct _helem
	{
		/* dati */
		struct _helem *next;
	} hashtable;
	la lista serve per la gestione delle collisioni

	la struttura segmento e` invece questa:
	typedef char bitmap_t;
	typedef struct
	{
		size_t     numpages;
		size_t     pagesize;
		long       __firstfree;
		bitmap_t * __bitmap;
		void     * __hashtable;
		void     * __data;
	} SEG_T;
	
	SEG_T *SG_setup(size_t pagesize, size_t numpages, void *hashtable); /* setuppa un segmento di numpages grandi pagesize */
	void *SG_malloc(SEG_T *seg); /* alloca un elemento nel segmento, lo marca come utilizzato e ritorna il ptr */
	void SG_free(void *p, SEG_T *seg); /* libera un elemento nel segmento */
	/* SG_realloc: non e` possibile una realloc(), in quanto le pagine di segmento sono di dim. fissa. */
	/* SG_calloc: un elemento alla volta, inutile una calloc() */
	void SG_set_err_func(void (*errfunc)(char *)); /* stabilisce la funzione da chiamare se la malloc(3) fallisce */
	void SG_destroy(SEG_T *seg) /* dealloca l`intero segmento */

	internamente la memoria e` gestita mediante una bitmap che indica lo stato delle pagine all`interno dell`area di
	memoria allocata realmente dalla malloc() con la SG_setup().
	0 == pagina non utilizzata
	1 == pagina utilizzata.

	la SG_setup() alloca l`area di memoria basandosi sui dati passati e inizializza la bitmap. e` consigliabile quindi
	che il numero di pagine sia un multiplo di sizeof(bitmap_t).
	dopo la SG_setup() la memoria allocata e` memset()tata a 0x0, e la bitmap pure. firstfree indica l`offset della
	prima pagina libera, aggiornato di volta in volta tramite l`algoritmo di ricerca della prossima pagina libera,
	in modo da non dover iniziare tutte le volte dalla prima pagina la ricerca. quando viene chiamata la SG_free(),
	essa ricava il numero di pagina che e` stato richiesto liberare, se esso e` minore di firstfree questi viene 
	modificato.
	
	la SG_malloc() mediante l`algoritmo di ricerca trova la prima pagina libera, la setta come utilizzata nella
	bitmap e ritorna il ptr al chiamante.
	se non sono disponibili pagine libere, il segmento subisce una realloc()azione e conseguente aggiornamento.
	i passi sono i seguenti:
		* aggiornamento di num_pages.
		* riallocazione della bitmap, calcolando la nuova dimensione e memset()ando la nuova parte della bitmap a 0x0.
		* aggiornamento di firstfree alla prima pagina della nuova parte del segmento
		* riallocazione dell`intero segmento:
			* se l`offset ottenuto dalla realloc() e` == 0, il compito e` finito e viene ritornata la firstfree
			* se l`offset ottenuto dalla realloc() e` != 0, vengono aggiornati tutti i puntatori presenti nella
			  hashtable associata al segmento.
	la SG_free() verifica che il puntatore passato appartenga al segmento e sia != NULL ed in caso affermativo
	provvede a memset()tare l`area interessata, aggiornare la bitmap e di conseguenza firstfree.

	la SG_set_err_func() serve per impostare la funzione da chiamare in caso di errore proveniente dalle func
	della libc sottostante

	la SG_destroy() opera la completa deallocazione del segmento e conseguente pulizia della hashtable associata


	* queste struct sono state modificate ed e` stata creata l`astrazione di 'tabella' che alloca e dealloca
	automaticamente il segmento associato. consultare memory.c x dettagli.

formato database: db berkeley, con metodo hash(3)
lettura dei dati:
	al boot i database vengono letti e inseriti in una tabella TABLE_T, e viene avviato l`io loop.

scrittura dei dati:
	durante il funzionamento i database su disco non vengono toccati, ma si opera solo sui dati in
	memoria. ogni x secondi viene effettuato il flush su disco, il vecchio db viene archiviato
	in una directory e viene scritto il nuovo db a partire dai dati che sono in memoria.


IO LOOP:
	basato su select(), inutile usare la poll poiche` c`e` un solo descriptor.
	l`io loop implementa il layer piu` basso per la lettura e scrittura da socket, legge buffer
	di dati e scrive altrettanti.
	ad ogni giro vengono letti i dati pendenti in un buffer che viene successivamente parsato
	ed eseguiti i comandi associati. dopo il parsing vengono eseguite le funzioni di + alto
	livello che riempiranno il buffer di uscita.
	dopo la lettura di un chunk avviene la scrittura dei dati che sono stati processati, magari
	ottimizzando le funzioni di help, poiche` molti help potrebbero far crescere spropositamente
	il buffer di uscita. la coda di uscita non sarebbe quindi un semplice buffer di caratteri,
	ma una lista di richieste:
	struct IOreq
	{
		uint8_t type; /* SIMPLE_REQ, HELP_REQ */
		size_t len; /* dimensione del buffer nel caso di SIMPLE_REQ, del path al file in caso di HELP_REQ */
		char *buf; /* ptr ai dati */
	};
		

